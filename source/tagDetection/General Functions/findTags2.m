function tags = findTags2(tagData, preTagData, postTagData, nBits, nTags, mirrored)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% findTags: find binary synchronization tags in a vector of digital data.
% usage:  tags = tagData(tagData[, nTags])
%
% where,
%    tags is a struct array containing a list of the tags found within the
%       tagData. Each element contains the decoded tag ID number, the start
%       index of the tag (rising edge of the start marker), and the stop 
%       index of the tag (falling edge of the end marker).
%    tagData is a 1D vector of tag data. It should be logical type, or any
%       type that can be sensibly cast to logical.
%    preData is an optional 1D vector of tag data from the file preceding
%       the current file. Include it if you want to be able to detect tags
%       that overlap the previous file. Default: []
%    postData is an optional 1D vector of tag data from the file after the
%       current file. Include it if you want to be able to detect tags
%       that overlap the next file. Default: []
%    nBits is an optional number of bits to expect in the tag data.
%       Providing this can improve reliability of tag IDs where there is 
%       the possibility of missing chunks of data. If omitted, or set to 
%       NaN (default), tags with any number of bits are identified without 
%       generating an error.
%    nTags is an optional number describing the maximum # of tags to find.
%       If omitted, or set to Inf (default), all tags are found.
%    mirrored is an optional boolean indicating whether or not to expect
%       mirrored tags; streams generated by old versions may produce
%       non-mirrored tags.
%
% Synchronizing two data streams requires a reference signal that is 
%   is present in both streams, and is either identical, or at least has
%   some precisely timed and identifiable corresponding features. A simple
%   solution is to generate a train of square pulses, and record as a 
%   channel in both streams. Then, matching up the nth rising edge in
%   each stream allows us to create a map between the sample indices in the
%   two streams.
%
%   Unfortunately, in practice, this is often insufficient. For example,
%   for long recording sessions, the data will most likely be chunked into
%   many files, and may be very long. Then, to find, for example, the
%   the 1,882,113th pulse in each stream can be very computationaly
%   intensive - we would have to count pulses from the very beginning of
%   both streams to be sure!
%
%   Or suppose one stream has data missing? Perhaps one of the streams had 
%   a hiccup and lost some time, or perhaps a whole file was deleted for 
%   some reason. Then the whole scheme falls apart - how many pulses are 
%   missing? Who knows?! Even worse if the experimenter is unaware of the 
%   data loss. Headache city.
%
%   Synchronization tags are designed to be a step up. They provide
%   regular, uniquely identifiable, binary "time stamps" in each stream 
%   that can be matched up without counting from the beginning of the data
%   streams. See the function findTags for a detailed description of their
%   structure.
%
% findTags looks through a vector of binary data to identify these "binary 
%   synchronization tags". These tags have a particular format, designed
%   to be sampled simultaneously by two different data acquisition devices.
%   After acquisition, the binary sync tags can be used to easily and
%   accurately align the two data streams from the two devices, even if
%   they have time offsets, missing data, or different sampling rates.
%   The format of the binary tags is as follows:
%
%   1_       ________   _       _         _   _   _    _   _   _          _       _   ________
%   0_  ____|        |_| |_____| |_  ... | |_| |_| |__| |_| |_| |_ ...  _| |_____| |_|        |______
%
%           |<== M1 ==>|<A>|<B>|<C>| ... |<D>|<E>|<F>|<f>|<e>|<d>| ... |<c>|<b>|<a>|<== M2 ==>|
%                      |<========= Tag ID ==========>|<==== Mirrored Tag ID ======>|
%
%  M1: Start marker
%  A: 1st bit - an "on" bit
%  B: 2nd bit - an "off" bit
%  C: 3rd bit - an "on" bit
%  ...
%  D: N-2 bit - an "on" bit
%  E: N-1 bit - an "on" bit
%  F: Nth bit - an "on" bit
%  f: Nth bit (mirror of F)
%  e: N-1 bit (mirror of E)
%  d: N-1 bit (mirror of D)
%  ...
%  c: 3rd bit (mirror of C)
%  b: 2nd bit (mirror of B)
%  a: 1st bit (mirror of A)
%  M2: End marker.
%
%   The start marker (M1) consists of one long high period followed by a low
%       period of width pulseWidth. The high period should be at least
%       several times longer than one pulseWidth
%
%   The Tag ID section (parts A-F) contains a binary representation of a 
%   whole number, which is the "tag ID". A valid tag ID section:
%       - consist of a series of one or more "bits", each of which is one of
%           - "on"  (one high pulseWidth, one low pulseWidth)
%           - "off" (two low pulseWidths)
%       - be unique to the data set. Typically it will be a
%           uniformly increasing binary number starting with 1. 
%       - have at least one "on" bit (a tag with all "off" bits is invalid)
%
%   The mirrored Tag ID section (parts f-a) contains a mirrored repeat of
%   the initial Tag ID section. This is for error-checking purposes; it
%   allows detection of missing or corrupted bits of the initial Tag ID>
%
%   The end marker (M2) consists of one low pulseWidth, followed by a long high
%       period. The high period should be the same length as the high
%       period for the start marker.
%
% See also: makeSyncTag

% Version: <version>
% Author:  Brian Kardon
% Email:   bmk27=cornell*org, brian*kardon=google*com
% Real_email = regexprep(Email,{'=','*'},{'@','.'})
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

if ~exist('preTagData', 'var') || isempty(preTagData)
    preTagData = [];
end
if ~exist('postTagData', 'var') || isempty(postTagData)
    postTagData = [];
end
if ~exist('nBits', 'var') || isempty(nBits)
    nBits = NaN;
end
if ~exist('nTags', 'var') || isempty(nTags)
    nTags = Inf;
end
if ~exist('mirrored', 'var') || isempty(mirrored)
    mirrored = true;
end

%% Prepare
% Initialize output tags structure
tags = struct('ID', {}, 'start', {}, 'end', {}, 'reliability', {});

tagDataLength = length(tagData);
preTagDataLength = length(preTagData);
postTagDataLength = length(postTagData);
% Concatenate preTagData and postTagData with tagData.
tagData = [preTagData, tagData, postTagData];

% Ensure tag data is a column vector
if isrow(tagData)
    tagData = tagData';
end

% Reliability is a rough measure of how reliable the tag is. 0 means the
%   tag had no irregularities. Less than zero means there were some
%   irregularities that cast doubt on the tag's reliability.
%   This should primarily be used to choose which tag to believe, when two
%   of them contradict each other.
baseReliability = 0;

%% Identify pulse locations
% Find where tagData is high
risingEdgeTimes = find(diff(tagData)==1)+1;
fallingEdgeTimes = find(diff(tagData)==-1);
% Note that the above will NOT mark a high on the first sample as a rising edge.
%   which is good.

if isempty(risingEdgeTimes) || isempty(fallingEdgeTimes)
    % No tags.
    return;
end

% Discard initial falling edge if it precedes the initial rising edge
if fallingEdgeTimes(1) < risingEdgeTimes(1)
    fallingEdgeTimes(1) = [];
end
% Discard final rising edge if it follows the final falling edge
if risingEdgeTimes(end) > fallingEdgeTimes(end)
    risingEdgeTimes(end) = [];
end

if length(fallingEdgeTimes) ~= length(risingEdgeTimes)
    error('Rising/falling edges do not match up. Something has gone wrong.');
end

% Match up rising edges and falling edges to get pulses
pulseWidthTimes = fallingEdgeTimes - risingEdgeTimes + 1;

if length(pulseWidthTimes) < 2
    % No tags found.
    return;
end

%% Determine pulse structure of file
tagStruct = struct();

% Cluster pulses into two groups by pulse width - marker pulses and data pulses
pulseTypeIdx = kmeans(pulseWidthTimes, 2);
[pw1s, badPw1s] = rmoutliers(pulseWidthTimes(pulseTypeIdx==1), 'quartiles');
[pw2s, badPw2s] = rmoutliers(pulseWidthTimes(pulseTypeIdx==2), 'quartiles');
pw1 = mean(pw1s);
pw2 = mean(pw2s);

pw1std = std(pw1s);
pw2std = std(pw2s);

if pw1 < pw2
    % The first pulses class must be data, and the second must be markers
    tagStruct.pulseId = 1;
    tagStruct.markerId = 2;
    tagStruct.pulseWidth = pw1;
    tagStruct.markerWidth = pw2;
    tagStruct.pulseStd = pw1std;
    tagStruct.markerStd = pw2std;
    badPulseIdx = find(badPw1s);
    badMarkerIdx = find(badPw2s);
else
    % The first pulses class must be markers, and the second must be data
    tagStruct.pulseId = 2;
    tagStruct.markerId = 1;
    tagStruct.pulseWidth = pw2;
    tagStruct.markerWidth = pw1;
    tagStruct.pulseStd = pw2std;
    tagStruct.markerStd = pw1std;
    badPulseIdx = find(badPw2s);
    badMarkerIdx = find(badPw1s);
end

if ~isempty(badPulseIdx)
    fprintf('Warning, %d non-standard-width pulses found!\n', length(badPulseIdx));
    baseReliability = baseReliability - 1;
end
if ~isempty(badMarkerIdx)
    fprintf('Warning, %d non-standard-width markers found!\n', length(badMarkerIdx));
    baseReliability = baseReliability - 1;
end

%% Check for bad data
% Make sure marker and pulse lengths are stereotyped and widely separated
if tagStruct.pulseWidth + tagStruct.pulseStd > tagStruct.markerWidth - tagStruct.markerStd
    disp('ERROR! Marker widths and pulse widths are not well separated. Tag IDs are unreliable!');
    return;
end
% Make sure pulse length variation is not comparable to pulse length
if tagStruct.pulseStd / tagStruct.pulseWidth > 0.25
    disp('ERROR! Pulse widths have too much variation. Tag IDs are unreliable! Exiting.');
    return;
end
% Make sure marker length variation is not comparable to marker length
if tagStruct.markerStd / tagStruct.markerWidth > 0.25
    disp('ERROR! Marker widths have too much variation. Tag IDs are unreliable! Exiting.');
    return;
end

firstSample = risingEdgeTimes(1) + round(tagStruct.pulseWidth/2);
lastSample = risingEdgeTimes(end) + round(tagStruct.pulseWidth/2);
numPulses = (lastSample - firstSample) / tagStruct.pulseWidth;
sampleTimes = firstSample + (1:numPulses) * tagStruct.pulseWidth;
values = logical(tagData(sampleTimes));
symbols = {'0', '1'};
strData = join(symbols(values + 1), ''); strData = strData{1};

matches = regexp(strData, '1{8,12}0((00|10)*10(00|10)*)01{8,12}', 'tokens');

tagNumbers = cellfun(@(m)m{1}(1:2:end), matches, 'UniformOutput', false);

disp('hi');